package ccf_csp;
/*201909-1 	小明种苹果
题目描述
小明在他的果园里种了一些苹果树。为了保证苹果的品质，在种植过程中要进行若干轮疏果操作，也就是提前从树上把不好的苹果去掉。
第一轮疏果操作开始前，小明记录了每棵树上苹果的个数。每轮疏果操作时，小明都记录了从每棵树上去掉的苹果个数。
在最后一轮疏果操作结束后，请帮助小明统计相关的信息。

输入格式
从标准输入读入数据。
第1行包含两个正整数N和M，分别表示苹果树的棵数和疏果操作的轮数。
第 1+i 行（1≤i≤N），每行包含 M+1 个整数ai0，ai1,⋯，aiM。其中 ai0 为正整数，表示第一轮疏果操作开始前第 i 棵树上苹果的个数。
aij（1≤j≤M）为零或负整数，表示第j轮疏果操作时从第i棵树上去掉的苹果个数。如果为零，表示没有去掉苹果；如果为负，其绝对值为去掉的苹果个数。
每行中相邻两个数之间用一个空格分隔。

输出格式
输出到标准输出。输出只有一行，包含三个整数T、k和P。其中，
T为最后一轮疏果操作后所有苹果树上剩下的苹果总数（假设苹果不会因为其他原因减少）；
k为疏果个数（也就是疏果操作去掉的苹果个数）最多的苹果树编号（如有并列，输出满足条件的最小编号）；
P为该苹果树的疏果个数。
相邻两个数之间用一个空格分隔。输入数据保证是正确的，也就是说，每棵树在全部疏果操作结束后剩下的苹果个数是非负的。

样例1输入
3 3
73 -8 -6 -4
76 -5 -10 -8
80 -6 -15 0
样例1输出
167 2 23
样例1解释
第1棵苹果树的疏果个数为8+6+4=18，第2棵为5+10+8=23，第3棵为6+15+0=21，
因此最后一轮疏果操作后全部苹果树上的苹果个数总和为(73-18)+(76-23)+(80-21)=167，疏果个数最多的是第2棵数，其疏果个数为23。

样例2输入
2 2
10 -3 -1
15 -4 0
样例2输出
17 1 4
样例2解释
两棵树的疏果个数均为4，应该输出编号最小的第1棵树。

子任务
|aij|≤10^6，对所有1≤i≤N,0≤j≤M*/

import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

public class XiaoMingZhongPingGuo {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		int M = sc.nextInt();
		int[][] nums = new int[N][2];
		int total = 0;
		
		for(int i=0;i<N;i++) {
			total += sc.nextInt();
			nums[i][0] = i+1;
			
			for(int j=0;j<M;j++)
				nums[i][1] += sc.nextInt();
			
			total += nums[i][1];
		}
		
		Arrays.sort(nums, Comparator.comparingInt(num -> num[1]));
		
		System.out.println(total + " " + nums[0][0] + " " + -nums[0][1]);
	}
}
